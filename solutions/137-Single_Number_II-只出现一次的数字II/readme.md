# 137、只出现一次的数字II
>tag: python3 、 位运算

***
### 题目描述

&emsp;&emsp;给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

**说明**:  
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### 示例1

```
  输入: [2,2,3,2]
  输出: 3
```

### 示例2

```
  输入: [0,1,0,1,0,1,99]
  输出: 99
```

***
### 题目链接
[137.只出现一次的数字II](https://leetcode-cn.com/problems/single-number-ii/)

***
### 题解

* **位运算**

  同样的我们可以通过位运算得到结果，由于 `x^x=0`，那么显然一个标志位不能计算一个数是否出现了三次(只能判断两次)。这里我们考虑一个比特位使用两个标志位来讨论变化情况

  | get | once | twice |
  | :-: | :-: | :-: |
  | 1 | 0 | 0 |
  | 1 | 1 | 0 |
  | 1 | 0 | 1 |

  其中转移顺序按行上下顺序转移，第三行转移至第一行。当收到的新值为 `0` 时，两值不变。那么我们就可以得到 `once=(once^x)&(~twice)`，随后我们可以计算 `twice` 的计算方法，但是实际程序运行过程中，`once` 的值会发生改变，我们需要用转移后的 `once` 的值进行计算，又最终的表达式中我们需要使用到 `twice^x` ，那么我们就可以得到

  | twice^x | new_once | new_twice |
  | :-: | :-: | :-: |
  | 1 | 1 | 0 |
  | 1 | 0 | 1 |
  | 0 | 0 | 0 |
  | 0 | 1 | 0 |

  则最终 `twcie = (twice^x)&(~once)`。

  ```python
  class Solution:
      def singleNumber(self, nums: List[int]) -> int:
          once, twice = 0, 0
          for i in nums:
              once = (once ^ i) & (~twice)
              twice = (twice ^ i) & (~once)
          return once
  ```

  &emsp;&emsp;最终结果，*运行时间44ms*，超过79.18%；*占用内存14.8MB*，超过25.00%。

* **一行 - 数学**

  根据题意我们可以知道，数组中除了一个数其他所有数字都出现了三次，那么我们就可以首先将数组转化为集合，随后并求和之后乘三，那么这时与原数组求和的差就差了两倍只出现一次的数字。

  ```python
  class Solution:
      def singleNumber(self, nums: List[int]) -> int:
          return (3*sum(set(nums)) - sum(nums)) // 2
  ```

  &emsp;&emsp;最终结果，*运行时间40ms*，超过89.24%；*占用内存15.3MB*，超过25.00%。
