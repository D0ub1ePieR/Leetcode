# 204、计算质数
>tag: python 、 哈希表 、 数学

***
### 题目描述

&emsp;&emsp;统计所有小于非负整数 `n` 的质数的数量。

### 示例

```
  输入: 10
  输出: 4
  解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

***
### 题目链接
[204. 计算质数](https://leetcode-cn.com/problems/count-primes/)

***
### 题解

&emsp;&emsp;最直观的方法便是有 `2` 循环至 `n` 逐个检查是否为质数并统计，时间复杂度为 `O(nlogn)`。有没有更加高效的方法呢？数学家厄拉多塞发明了一种质数的筛选方法。这种方法以空间换时间。构建了一个长度为 `n` 的数组。首先我们将 `0,1` 先置为 `1`，因为他们都不是质数。最后开始循环遍历，下标为 `i`，碰到 `0` 的时候说明该数必定为质数，并且将数组中 `[i, 2i, 3i, ...]` 全部置为 `1`(这也就保证了碰到为0的数必定没有因子能够整除它)。直到循环结束后统计数组中 `0` 的个数即为质数的个数。

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n in [0, 1]:
            return 0
        flag = [0] * n
        flag[0] = 1
        flag[1] = 1
        for i in range(n):
            if flag[i] == 0:
                k = 2
                while k * i < n:
                    flag[k * i] = 1
                    k += 1
        return flag.count(0)
```

&emsp;&emsp;最终结果，*运行时间1860ms*，超过10.98%；*占用内存25.2MB*，超过68.35%。可见效果还不是那么的明显，那么还有哪些地方可以改进呢。在找到 `0` 之后，我们本来是将 `i` 从自身到k倍都置0，但是我们可以发现对于小于 `i` 的倍数即 `[i, 2i, ..., (i-1)i]` 这些值在遍历到 `i` 之前肯定都已经被对应的 `[1, 2, 3, ... i-1]` 的倍数置为 `1` 过。那么这里就可以优化为置 `[i*i, (i+1)i, ...]` 为 `1`。有我们可以发现对于最外层循环原本为 `n`，但实际上如果这个数大于 `sqrt(n)` 经过了之前的循环还为 `0` 时，由于上述描述的， 这个数对其后造成的影响会从 `sqrt(n) * sqrt(n) + 1` 开始，即对结果不会产生影响了，那么我们就可以将最外层循环优化为 `sqrt(n) + 1`。

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n in [0, 1]:
            return 0
        flag = [0] * n
        flag[0] = 1
        flag[1] = 1
        for i in range(int(math.sqrt(n))+1):
            if flag[i] == 0:
                k = i
                while k * i < n:
                    flag[k * i] = 1
                    k += 1
        return flag.count(0)
```

&emsp;&emsp;最终结果，*运行时间852ms*，超过30.93%；*占用内存24.9MB*，超过68.61%。可以发现速度快乐将近一倍，但是看起来还有优化的空间。这里使用到类似向量化的思想，即将循环转变为向量操作，我们将置 `[i*i, (i+1)i, ...]` 为 `1` 的操作转变为数组一步的操作，不再使用循环

```python
- k = 2
- while k * i < n:
-     flag[k * i] = 1
-     k += 1
+ flag[i*i:n:i] = [1] * ((n-1-i*i) // i + 1)
```

&emsp;&emsp;最终结果，*运行时间108ms*，超过92.78%；*占用内存36.5MB*，超过6.58%。可以发现得到了质的飞跃，从占用内存角度可以从一定程度上也看做使用空间换时间，每次置 `1` 都会新建一个变长的数组。*再观察排列在前的代码可以发现都是通过打表的方法来获得更快得运行速度。*
