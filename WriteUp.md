# 3-无重复字符的最长子串
  使用双指针和一个记录最长长度的变量，初始两个指针都指向初始位置，第一个指针保持不动，第二个指针逐个向后移动，如果在两个指针中间
  的值能够找到第二个指针指向的数那么就将一号指针指向这个索引的后一个位置，保证两个指针中间的值都是没有出现重复的。每次循环都将两
  个指针相隔的长度与记录变量比较取较大值，直到二号指针执行到数组末尾便结束，输出记录变量便是最大值

# 26-删除排序数组中的重复项
  刚开始想记录个数res，遍历中每次查找nums[:res]中是否有当前元素，逐个删除多与元素，但是发现会超时
  最终采用，记录res，因为已经是有序序列，每次将当前数与nums[res]比较，如果不等就将这个数转移到res+1位置，最后删除res后的所有数
  !测试用例中会出现[]空数组的情况所以最后不能直接返回res，需要使用len返回，也可以对[]进行特殊判断
  
# 27-移除元素
  和26相同，记录res，遍历中遇到与val不同的数便将他置于res位置，最后返回res即为最终个数

# 42-接雨水
  *流程比较复杂，但是速度似乎和leetcode上最快的算法没有做操作优化时差不多*</br>
  * 第一步在传入的数组两边加入两个0，即表示两边都无法存入雨水，两边都是最低的
  * 第二步遍历高度，找出**所有的极大值点**(即大于左右侧的点，连续相等的值去最后一个)，得到数组mid(数组中存放的为height中的index)
    * 如果mid数组为空，则直接返回0
    * mid不为空进入下一步
  * 第三步为一个循环，直到整个mid数组中值得趋势为递增到递减(即mid中只有一个极大值)，使用num存放mid中极大值个数
    * 对于mid中极大值的计算要特殊考虑，需要去除mid中对应的height的值类似 *2-5-5-7* 这种情况
    * 得到mid中所有的极大值在mid中的index放入tmid中后，对mid进行处理，只保留
    
      * mid中tmid第一个index前的值
      * mid中tmid最后一个index后的值
      * mid中tmid其他值和tmid中相邻两个mid的index之间在height中的值比两端tmid对应在mid中index在height中的值大的值
      * **将代码中注释掉的输出取消注释后可以更好的得理解**，最终目的是得到所有能接水的坑的两边边界在height中的index存入mid中
  * 最后去掉mid两端的0，遍历mid，取相邻两个值中较小的一个，即当前坑最高的高度，遍历height中这个坑的index，算出所有雨水总和

#
